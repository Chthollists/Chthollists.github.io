---
title: '每日一题:LeetCode:1944.好子集的数目'
reward: true
declare: true
gitalkenable: true
categories: CodeRecord
toc: true
tags:
  - 状态压缩
  - 动态规划
date: 2022-02-22 15:58:16
top:

---

---

* 每日一题：LeetCode：1944.好子集的数目
  * 时间：2022-02-22
  * 力扣难度：Hard
  * 个人难度：Hard+
  * 数据结构：数组、哈希表
  * 算法：状态压缩、动态规划


---

<!-- more -->

# 2022-02-22：LeetCode：1944.好子集的数目

## 1. 题目描述

* 题目：[原题链接](https://leetcode-cn.com/problems/the-number-of-good-subsets/)

  * 给你一个整数数组 nums 。如果 nums 的一个子集中，所有元素的乘积可以表示为一个或多个**互不相同的质数**的乘积，那么我们称它为 好子集 。
  * 比方说，如果 nums = [1, 2, 3, 4] ：
    * [2, 3] ，[1, 2, 3] 和 [1, 3] 是 好子集，乘积分别为 6 = 23 ，6 = 23 和 3 = 3 。
    * [1, 4] 和 [4] 不是 好子集，因为乘积分别为 4 = 22 和 4 = 22 。
  * 请你返回 nums 中不同的 好 子集的数目对 109 + 7 取余 的结果。
  * nums 中的 子集 是通过删除 nums 中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。
  * 如果两个子集删除的**下标不同**，那么它们被视为不同的子集。
  * `1 <= nums.length <= 10^5`
  * `1 <= nums[i] <= 30`

* 输入输出规范
  * 输入：整数数组
  * 输出：好子集的个数
* 输入输出示例
  * 输入：nums = [4,2,3,15]
  * 输出：5


---

## 2. 方法一：状态压缩 & 动态规划

* 思路：根据素数个数状态压缩，二进制表示方案

  * 根据题意可知，数组中数字的范围是1~30，由于定义的好子集的乘积只能拆解为**互不相同的素数**
    * 所以子集中一定不包含 4,8,9,12,16,18,20,24,25,27,28 这类包含平方因子的数
    * 所以子集中只能包含2,3,5,6,7,10,11,13,14,15,17,19,21,22,23,26,29,30这下可以拆分为不重复素数的数字，但至多出现一次
    * 特别的，数字 1 不会影响拆分的结果，即好子集可以没有 1 也可以有 1
  * 由于题目表示索引不同视为不同的数字，所以需要哈希表计数，且子集中可以出现任意个数的 1
  * 此外，对于 6, 15等**不包含平方因子的非素数**，其会与一些素数数字冲突，不能同时出现在子集中
  * 实际上，如果将子集中的所有数字都素数拆解(乘积拆解和分开拆解其实是一样的)，最终一定可以拆解为素数`[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]`的子集
  * 即**好子集本质上就是该素数集合中元素的组合**，再加上考虑特殊数字 1 的情况
  * 首先，根据这个特性，可以将30个数字压缩到十个素数，我们**使用一个长度为 10 的二进制数来表示某个数字使用这十个素数的情况**，该二进制数一共有$2^{10}$ (1024) 种情况
  * 接着，定义动态规划数组 `dp[i]`表示：**好子集的乘积对应的二进制序列的值为 i 时的方案个数**，即 i 对应一个二进制序列，表示使用到了哪些素数
  * 边界条件：根据 dp 数组的定义，其大小初始化为二进制序列的个数$2^{10}$，dp[0] = 1，表示不选择任何素数的方案只有一个
  * **状态转移方程**
    * 本题的状态转移方程比较抽象，当一个子集的乘积变化时，其实就是添加了一个新的数字 num
    * 此时，**拆解该数字 num，得到对应的素数二进制序列 use**，分析该二进制数与子集原来用到的素数二进制序列 set是否冲突
    * 冲突时，新的dp元素不变；不冲突时新的子集的方案数等于原子集方案数乘上新加数字 num 的个数，即 `dp[i | num] += dp[i]*count[num]`
  * 因此，遍历可能存在的数字 2 ~ 30，求出当该数字为子集新元素时，冲突情况，并更新 dp 数组
    * 对于没有出现的数字直接跳过
    * 对于出现的数字，求出其是否为非平方因子数，以及其拆解为素数时的二进制数 use
    * 遍历 dp 数组，即各种可能的子集对应二进制数 set，判断**是否有素数重复使用**(冲突、使用 & 运算)
    * 不冲突时，更新 dp 数组( | 运算)
  * 注意：以上都是忽略了数字 1 的分析，当求解完了 dp 数组后，求解 dp 数组的和，再乘以 $2^{count[1]}$(因为可以存在任意个1)，结果表示方案总数

* 题解

  > ```java
  > public int numberOfGoodSubsets(int[] nums) {
  >     int mod = (int) 1e9+7;
  >     int n = nums.length;
  >     int[] primes = new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29}; 
  >     int[] count = new int[31];
  >     for(int num : nums) count[num]++;
  >     int total = 1 << 10; // 2^10
  >     // dp[i] 表示 当前子集的乘积是 i 时的方案数，素数乘积 i 对应一个二进制序列(10位)，表示用到了哪些素数(拆解)
  >     long[] dp = new long[total];
  >     dp[0] = 1;
  > 
  >     // 分析一个数 num (2~30) 可以分解成哪些素数
  >     for(int num = 2; num < 31; num++) {
  >         if(count[num] == 0) continue;
  >         int temp = num, use = 0;
  >         boolean flag = true; // 表示 i 能否除以多次同一个质数，即当前子集不满足互不相同质数的条件
  >         for(int i = 0; i < primes.length; i++) {
  >             int cnt = 0;
  >             while(temp % primes[i] == 0){
  >                 cnt++;
  >                 use |= 1 << i;
  >                 temp /= primes[i];
  >             }
  >             if(cnt > 1){
  >                 flag = false;
  >                 break;
  >             }
  >         }
  >         if(!flag) continue;
  >         // 判断一个数 num (2~30)可以添加到哪些子集中
  >         for(int set = 0; set < total; set++) {
  >             // 两者不重复表示 num 对应的素数集合 use 可以加入到 set 子集中
  >             if((set & use) == 0) {
  >                 dp[set | use] = (dp[set | use] + dp[set]*count[num]) % mod;
  >             }
  >         }
  >     }
  >     long res = 0;
  >     for(int i = 1; i < total; i++) {
  >         res = (res + dp[i]) % mod;
  >     }
  >     // 特殊情况：1 的选择与否
  >     for(int i = 0; i < count[1]; i++) res = res * 2 % mod;
  >     return (int) res;
  > }
  > ```

* 复杂度分析：n 是数组的大小

  * 时间复杂度：$O(n+C*2^C)$，C 是整数数组中包含的素数的个数
  * 空间复杂度：$O(C*2^C)$

